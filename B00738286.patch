diff --git a/run_viewer.sh b/run_viewer.sh
new file mode 100755
index 0000000..03b4b4c
--- /dev/null
+++ b/run_viewer.sh
@@ -0,0 +1,3 @@
+#!/usr/bin/bash
+./build/out/bin/qoi_viewer $1
+
diff --git a/src/qoi/qoi.c b/src/qoi/qoi.c
index 962182f..6ccd666 100644
--- a/src/qoi/qoi.c
+++ b/src/qoi/qoi.c
@@ -4,7 +4,210 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 
-void *qoi_decode(void const *UNUSED(data), uint64_t UNUSED(size), qoi_desc_t *UNUSED(out_desc)) {
-  return NULL;
+/*
+TODO:
+build and run debug with one key press
+fix warnings about const
+add more basic error warnings?
+formatting
+multiple files?
+*/
+
+// bit shift two bytes into one 16-bit number (BE)
+uint16_t bytes_to_uint16(uint8_t const *data) {
+  return (uint16_t)data[1] | (uint16_t)data[0] << 8;
+}
+
+// bit shift four bytes into one 32-bit number (BE)
+uint32_t bytes_to_uint32(uint8_t const *data) {
+  return (uint32_t)data[3] | (uint32_t)data[2] << 8 
+    | (uint32_t)data[1] << 16 | (uint32_t)data[0] << 24;
+}
+
+// read the file header into the description struct
+void read_header(qoi_desc_t *out_desc, uint8_t const *data){
+  out_desc->width = bytes_to_uint32(data+4);
+  out_desc->height = bytes_to_uint32(data+8);
+  out_desc->channels = data[12];
+  out_desc->colorspace = data[13];
+}
+
+// print the file header
+void print_header(qoi_desc_t *header) {
+  printf("QOI File Header\n"
+    "Width     : %i\n"
+    "Height    : %i\n"
+    "Channels  : %i\n"
+    "Colorspace: %i\n", header->width, header->height, header->channels, header->colorspace);
+}
+
+// check the first four bytes match "qoif"
+int is_valid_file_type(uint8_t const *data) {
+  char magic[5];
+  strncpy(magic, data, 4);
+  magic[4] = '\0';          // null terminate for strcmp
+  return (strcmp(magic, "qoif") == 0);
+}
+
+// identify the type of chunk by examining the first byte
+enum opcode get_opcode(uint8_t const *chunk) {
+
+  uint8_t first_byte = chunk[0];
+  switch (first_byte) {  // check for 8-bit opcodes first
+  case 0xFE:
+    return QOI_OP_RGB;
+  case 0xFF:
+    return QOI_OP_RGBA;
+  default:
+  {
+    uint8_t opcode = first_byte >> 6;  // check for 2-bit opcodes
+    switch (opcode) {
+    case 0x00:
+      return QOI_OP_INDEX;
+    case 0x01:
+      return QOI_OP_DIFF;
+    case 0x02:
+      return QOI_OP_LUMA;
+    case 0x03:
+      return QOI_OP_RUN;
+    default:
+      printf("ERROR: Opcode not recognized: %x", first_byte);
+      exit(1);
+    }
+  }
+  }
+}
+
+// decode the RGB chunk
+void decode_RGB(uint8_t const *next_read, uint8_t *next_write, uint8_t *prev_write) {
+  memcpy(next_write, next_read+1, 3);  // skip opcode byte and copy next three (RGB values)
+  next_write[ALPHA] = prev_write[ALPHA];
+}
+
+// decode the RGBA chunk
+void decode_RGBA(uint8_t const *next_read, uint8_t *next_write) {
+  memcpy(next_write, next_read+1, BYTES_PER_PIXEL);  // skip opcode byte and copy next four (RGBA values)
+}
+
+// decode the INDEX chunk
+void decode_INDEX(uint8_t const *next_read, uint8_t *next_write, uint8_t *prev_pixels) {
+  uint8_t index = (*next_read) & INDEX_MASK;
+  memcpy(next_write, &prev_pixels[index*BYTES_PER_PIXEL], BYTES_PER_PIXEL);
+}
+
+// decode the DIFF chunk
+void decode_DIFF(uint8_t const *next_read, uint8_t *next_write, uint8_t *prev_write) {
+  int8_t diff_red   = (((*next_read) & DIFF_R_MASK) >> DIFF_R_SHIFT) - DIFF_BIAS;
+  int8_t diff_green = (((*next_read) & DIFF_G_MASK) >> DIFF_G_SHIFT) - DIFF_BIAS;
+  int8_t diff_blue  = (((*next_read) & DIFF_B_MASK) >> DIFF_B_SHIFT) - DIFF_BIAS;
+  next_write[RED]   = prev_write[RED]   + diff_red;
+  next_write[GREEN] = prev_write[GREEN] + diff_green;
+  next_write[BLUE]  = prev_write[BLUE]  + diff_blue;
+  next_write[ALPHA] = prev_write[ALPHA];
+}
+
+// decode the LUMA chunk
+void decode_LUMA(uint8_t const *next_read, uint8_t *next_write, uint8_t *prev_write) {
+  int8_t diff_green = ((*next_read)    & LUMA_G_MASK) - LUMA_G_BIAS;
+  int8_t diff_red   = ((*(next_read+1) & LUMA_R_MASK) >> LUMA_R_SHIFT) + diff_green - LUMA_RB_BIAS;
+  int8_t diff_blue  = ( *(next_read+1) & LUMA_B_MASK) + diff_green - LUMA_RB_BIAS;
+  next_write[RED]   = prev_write[RED]   + diff_red;
+  next_write[GREEN] = prev_write[GREEN] + diff_green;
+  next_write[BLUE]  = prev_write[BLUE]  + diff_blue;
+  next_write[ALPHA] = prev_write[ALPHA];
+}
+
+// decode the RUN chunk
+uint8_t decode_RUN(uint8_t const *next_read, uint8_t *next_write, uint8_t *prev_write) {
+  uint8_t length = ((*next_read) & RUN_MASK) - RUN_BIAS;
+  for (uint8_t i=0;i<length;i++) {
+    memcpy(next_write,prev_write,BYTES_PER_PIXEL); 
+    next_write += BYTES_PER_PIXEL;
+  }
+  return length;
+}
+
+// add pixel to hash map
+void hash_pixel(uint8_t *pixel, uint8_t *prev_pixels) {
+  uint8_t index = (pixel[RED] * HASH_R + pixel[GREEN] * HASH_G + pixel[BLUE] * HASH_B + pixel[ALPHA] * HASH_A) % HASH_SIZE;
+  memcpy(&prev_pixels[index*BYTES_PER_PIXEL], pixel, BYTES_PER_PIXEL);
+}
+
+void *qoi_decode(void const *data, uint64_t size, qoi_desc_t *out_desc) {
+
+  if (!is_valid_file_type(data)) {
+    printf("Invalid file type\n");
+    return NULL;
+  }
+
+  read_header(out_desc, data);
+  print_header(out_desc);
+
+  uint8_t prev_pixels[HASH_SIZE * BYTES_PER_PIXEL] = {0};  // hash map of prev pixels
+
+  uint8_t *decoded_data = calloc((size_t)(out_desc->width * out_desc->height), BYTES_PER_PIXEL);
+  decoded_data[ALPHA] = 255; // set initial alpha to fully opaque
+
+  uint8_t const *next_read = &data[HEADER_SIZE];
+
+  uint8_t *next_write = decoded_data;   // points to start of next pixel
+  uint8_t *prev_write = decoded_data;   // points to start of prev pixel
+
+  unsigned chunks = 0;  // number of chunks read
+  unsigned pixels = 0;  // number of pixels decoded
+  
+  printf("Encoded data: %u bytes\n", size);
+  
+  while (next_read < (data+size-FOOTER_SIZE)){  // todo: detect end condition
+
+    enum opcode op = get_opcode(next_read);
+
+    switch (op) {
+    case QOI_OP_RGB:
+      decode_RGB(next_read, next_write, prev_write);
+      next_read += CHUNK_LEN_RGB;
+      break;
+    case QOI_OP_RGBA:
+      decode_RGBA(next_read, next_write);
+      next_read += CHUNK_LEN_RGBA;
+      break;
+    case QOI_OP_INDEX:
+      decode_INDEX(next_read, next_write, prev_pixels);
+      next_read += CHUNK_LEN_INDEX;
+      break;
+    case QOI_OP_DIFF:
+      decode_DIFF(next_read, next_write, prev_write);
+      next_read += CHUNK_LEN_DIFF;
+      break;
+    case QOI_OP_LUMA:
+      decode_LUMA(next_read, next_write, prev_write);
+      next_read += CHUNK_LEN_LUMA;
+      break;
+    case QOI_OP_RUN: {
+      uint8_t length = decode_RUN(next_read, next_write, prev_write);
+      next_read += CHUNK_LEN_RUN;
+      next_write += (length-1) * BYTES_PER_PIXEL;  // last increment happens later 
+      pixels += (length-1);
+      break;
+    }
+    }
+
+    // adds pixel to hash map
+    hash_pixel(next_write, prev_pixels);
+
+    // advance pointers
+    prev_write = next_write;
+    next_write += BYTES_PER_PIXEL;
+
+    // track progress
+    chunks++;
+    pixels++;
+  }
+  printf("Decoded data:\n"
+         "Bytes : %u\n"
+         "Chunks: %u\n"
+         "Pixels: %u\n", (out_desc->width * out_desc->height * 4), chunks, pixels);
+  return decoded_data;
 }
diff --git a/src/qoi/qoi.h b/src/qoi/qoi.h
index 4d6594b..088521d 100644
--- a/src/qoi/qoi.h
+++ b/src/qoi/qoi.h
@@ -13,6 +13,54 @@
 #define QOI_COLORSPACE_LINEAR 1  ///< all channels linear
 /// @}
 
+
+#define HEADER_SIZE    14
+#define FOOTER_SIZE     8
+#define BYTES_PER_PIXEL 4
+
+// byte indexes into a pixel
+#define RED   0
+#define GREEN 1
+#define BLUE  2
+#define ALPHA 3
+
+// lengths of chunk sizes in qoi format
+#define CHUNK_LEN_RGB   4
+#define CHUNK_LEN_RGBA  5
+#define CHUNK_LEN_INDEX 1
+#define CHUNK_LEN_DIFF  1
+#define CHUNK_LEN_LUMA  2
+#define CHUNK_LEN_RUN   1
+
+// bit masks to extract info from chunks
+#define INDEX_MASK  0b00111111
+#define DIFF_R_MASK 0b00110000
+#define DIFF_G_MASK 0b00001100
+#define DIFF_B_MASK 0b00000011
+#define LUMA_R_MASK 0b11110000
+#define LUMA_G_MASK 0b00111111
+#define LUMA_B_MASK 0b00001111
+#define RUN_MASK    0b00111111
+
+// shift sizes after masks
+#define DIFF_R_SHIFT 4
+#define DIFF_G_SHIFT 2
+#define DIFF_B_SHIFT 0
+#define LUMA_R_SHIFT 4
+
+// biases used to encode signed offsets as unsigned bytes
+#define DIFF_BIAS    2
+#define LUMA_G_BIAS 32
+#define LUMA_RB_BIAS 8
+#define RUN_BIAS    -1
+
+// hash function parameters
+#define HASH_SIZE 64
+#define HASH_R 3
+#define HASH_G 5
+#define HASH_B 7
+#define HASH_A 11
+
 /// Image description
 typedef struct qoi_desc_t {
   uint32_t width;      ///< image width, in pixels
@@ -21,6 +69,15 @@ typedef struct qoi_desc_t {
   uint8_t colorspace;  ///< image colorspace: see @ref colorspace
 } qoi_desc_t;
 
+enum opcode{
+  QOI_OP_RGB,
+  QOI_OP_RGBA,
+  QOI_OP_INDEX,
+  QOI_OP_DIFF,
+  QOI_OP_LUMA,
+  QOI_OP_RUN
+};
+
 /// Decodes the provided buffer into raw pixels
 /// \returns A pointer to the decoded image. The caller is responsible for freeing this memory.
 /// \param data A pointer to the buffer of pixels to decode
diff --git a/viewer/main.c b/viewer/main.c
index 46576d5..0dae94e 100644
--- a/viewer/main.c
+++ b/viewer/main.c
@@ -95,6 +95,10 @@ int main(int argc, char *argv[]) {
   void *pixels = qoi_decode(data, size, &desc);
   free(data);
 
+  // testing that doesn't require showing image
+  // return EXIT_SUCCESS;
+  // --------------
+
   if (!pixels) {
     puts("failed to decode image");
   } else if (desc.width > (uint32_t)INT32_MAX || desc.height > (uint32_t)INT32_MAX) {
